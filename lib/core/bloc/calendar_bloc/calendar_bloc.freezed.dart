// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'calendar_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$CalendarEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(DateTime newMonth) changeSelectedMonth,
    required TResult Function(DateTime newDate) changeSelectedDate,
    required TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)
        addNewEvent,
    required TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        deleteEvent,
    required TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        updateEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(DateTime newMonth)? changeSelectedMonth,
    TResult? Function(DateTime newDate)? changeSelectedDate,
    TResult? Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult? Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult? Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(DateTime newMonth)? changeSelectedMonth,
    TResult Function(DateTime newDate)? changeSelectedDate,
    TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_ChangeSelectedMonth value) changeSelectedMonth,
    required TResult Function(_ChangeSelectedDate value) changeSelectedDate,
    required TResult Function(_AddEvent value) addNewEvent,
    required TResult Function(_DeleteEvent value) deleteEvent,
    required TResult Function(_UpdateEvent value) updateEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult? Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult? Function(_AddEvent value)? addNewEvent,
    TResult? Function(_DeleteEvent value)? deleteEvent,
    TResult? Function(_UpdateEvent value)? updateEvent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult Function(_AddEvent value)? addNewEvent,
    TResult Function(_DeleteEvent value)? deleteEvent,
    TResult Function(_UpdateEvent value)? updateEvent,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CalendarEventCopyWith<$Res> {
  factory $CalendarEventCopyWith(
          CalendarEvent value, $Res Function(CalendarEvent) then) =
      _$CalendarEventCopyWithImpl<$Res, CalendarEvent>;
}

/// @nodoc
class _$CalendarEventCopyWithImpl<$Res, $Val extends CalendarEvent>
    implements $CalendarEventCopyWith<$Res> {
  _$CalendarEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitImplCopyWith<$Res> {
  factory _$$InitImplCopyWith(
          _$InitImpl value, $Res Function(_$InitImpl) then) =
      __$$InitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitImplCopyWithImpl<$Res>
    extends _$CalendarEventCopyWithImpl<$Res, _$InitImpl>
    implements _$$InitImplCopyWith<$Res> {
  __$$InitImplCopyWithImpl(_$InitImpl _value, $Res Function(_$InitImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitImpl implements _Init {
  const _$InitImpl();

  @override
  String toString() {
    return 'CalendarEvent.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(DateTime newMonth) changeSelectedMonth,
    required TResult Function(DateTime newDate) changeSelectedDate,
    required TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)
        addNewEvent,
    required TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        deleteEvent,
    required TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        updateEvent,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(DateTime newMonth)? changeSelectedMonth,
    TResult? Function(DateTime newDate)? changeSelectedDate,
    TResult? Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult? Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult? Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(DateTime newMonth)? changeSelectedMonth,
    TResult Function(DateTime newDate)? changeSelectedDate,
    TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_ChangeSelectedMonth value) changeSelectedMonth,
    required TResult Function(_ChangeSelectedDate value) changeSelectedDate,
    required TResult Function(_AddEvent value) addNewEvent,
    required TResult Function(_DeleteEvent value) deleteEvent,
    required TResult Function(_UpdateEvent value) updateEvent,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult? Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult? Function(_AddEvent value)? addNewEvent,
    TResult? Function(_DeleteEvent value)? deleteEvent,
    TResult? Function(_UpdateEvent value)? updateEvent,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult Function(_AddEvent value)? addNewEvent,
    TResult Function(_DeleteEvent value)? deleteEvent,
    TResult Function(_UpdateEvent value)? updateEvent,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class _Init implements CalendarEvent {
  const factory _Init() = _$InitImpl;
}

/// @nodoc
abstract class _$$ChangeSelectedMonthImplCopyWith<$Res> {
  factory _$$ChangeSelectedMonthImplCopyWith(_$ChangeSelectedMonthImpl value,
          $Res Function(_$ChangeSelectedMonthImpl) then) =
      __$$ChangeSelectedMonthImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DateTime newMonth});
}

/// @nodoc
class __$$ChangeSelectedMonthImplCopyWithImpl<$Res>
    extends _$CalendarEventCopyWithImpl<$Res, _$ChangeSelectedMonthImpl>
    implements _$$ChangeSelectedMonthImplCopyWith<$Res> {
  __$$ChangeSelectedMonthImplCopyWithImpl(_$ChangeSelectedMonthImpl _value,
      $Res Function(_$ChangeSelectedMonthImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? newMonth = null,
  }) {
    return _then(_$ChangeSelectedMonthImpl(
      null == newMonth
          ? _value.newMonth
          : newMonth // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$ChangeSelectedMonthImpl implements _ChangeSelectedMonth {
  const _$ChangeSelectedMonthImpl(this.newMonth);

  @override
  final DateTime newMonth;

  @override
  String toString() {
    return 'CalendarEvent.changeSelectedMonth(newMonth: $newMonth)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangeSelectedMonthImpl &&
            (identical(other.newMonth, newMonth) ||
                other.newMonth == newMonth));
  }

  @override
  int get hashCode => Object.hash(runtimeType, newMonth);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangeSelectedMonthImplCopyWith<_$ChangeSelectedMonthImpl> get copyWith =>
      __$$ChangeSelectedMonthImplCopyWithImpl<_$ChangeSelectedMonthImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(DateTime newMonth) changeSelectedMonth,
    required TResult Function(DateTime newDate) changeSelectedDate,
    required TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)
        addNewEvent,
    required TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        deleteEvent,
    required TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        updateEvent,
  }) {
    return changeSelectedMonth(newMonth);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(DateTime newMonth)? changeSelectedMonth,
    TResult? Function(DateTime newDate)? changeSelectedDate,
    TResult? Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult? Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult? Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
  }) {
    return changeSelectedMonth?.call(newMonth);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(DateTime newMonth)? changeSelectedMonth,
    TResult Function(DateTime newDate)? changeSelectedDate,
    TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
    required TResult orElse(),
  }) {
    if (changeSelectedMonth != null) {
      return changeSelectedMonth(newMonth);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_ChangeSelectedMonth value) changeSelectedMonth,
    required TResult Function(_ChangeSelectedDate value) changeSelectedDate,
    required TResult Function(_AddEvent value) addNewEvent,
    required TResult Function(_DeleteEvent value) deleteEvent,
    required TResult Function(_UpdateEvent value) updateEvent,
  }) {
    return changeSelectedMonth(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult? Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult? Function(_AddEvent value)? addNewEvent,
    TResult? Function(_DeleteEvent value)? deleteEvent,
    TResult? Function(_UpdateEvent value)? updateEvent,
  }) {
    return changeSelectedMonth?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult Function(_AddEvent value)? addNewEvent,
    TResult Function(_DeleteEvent value)? deleteEvent,
    TResult Function(_UpdateEvent value)? updateEvent,
    required TResult orElse(),
  }) {
    if (changeSelectedMonth != null) {
      return changeSelectedMonth(this);
    }
    return orElse();
  }
}

abstract class _ChangeSelectedMonth implements CalendarEvent {
  const factory _ChangeSelectedMonth(final DateTime newMonth) =
      _$ChangeSelectedMonthImpl;

  DateTime get newMonth;
  @JsonKey(ignore: true)
  _$$ChangeSelectedMonthImplCopyWith<_$ChangeSelectedMonthImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChangeSelectedDateImplCopyWith<$Res> {
  factory _$$ChangeSelectedDateImplCopyWith(_$ChangeSelectedDateImpl value,
          $Res Function(_$ChangeSelectedDateImpl) then) =
      __$$ChangeSelectedDateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DateTime newDate});
}

/// @nodoc
class __$$ChangeSelectedDateImplCopyWithImpl<$Res>
    extends _$CalendarEventCopyWithImpl<$Res, _$ChangeSelectedDateImpl>
    implements _$$ChangeSelectedDateImplCopyWith<$Res> {
  __$$ChangeSelectedDateImplCopyWithImpl(_$ChangeSelectedDateImpl _value,
      $Res Function(_$ChangeSelectedDateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? newDate = null,
  }) {
    return _then(_$ChangeSelectedDateImpl(
      null == newDate
          ? _value.newDate
          : newDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$ChangeSelectedDateImpl implements _ChangeSelectedDate {
  const _$ChangeSelectedDateImpl(this.newDate);

  @override
  final DateTime newDate;

  @override
  String toString() {
    return 'CalendarEvent.changeSelectedDate(newDate: $newDate)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangeSelectedDateImpl &&
            (identical(other.newDate, newDate) || other.newDate == newDate));
  }

  @override
  int get hashCode => Object.hash(runtimeType, newDate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangeSelectedDateImplCopyWith<_$ChangeSelectedDateImpl> get copyWith =>
      __$$ChangeSelectedDateImplCopyWithImpl<_$ChangeSelectedDateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(DateTime newMonth) changeSelectedMonth,
    required TResult Function(DateTime newDate) changeSelectedDate,
    required TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)
        addNewEvent,
    required TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        deleteEvent,
    required TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        updateEvent,
  }) {
    return changeSelectedDate(newDate);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(DateTime newMonth)? changeSelectedMonth,
    TResult? Function(DateTime newDate)? changeSelectedDate,
    TResult? Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult? Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult? Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
  }) {
    return changeSelectedDate?.call(newDate);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(DateTime newMonth)? changeSelectedMonth,
    TResult Function(DateTime newDate)? changeSelectedDate,
    TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
    required TResult orElse(),
  }) {
    if (changeSelectedDate != null) {
      return changeSelectedDate(newDate);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_ChangeSelectedMonth value) changeSelectedMonth,
    required TResult Function(_ChangeSelectedDate value) changeSelectedDate,
    required TResult Function(_AddEvent value) addNewEvent,
    required TResult Function(_DeleteEvent value) deleteEvent,
    required TResult Function(_UpdateEvent value) updateEvent,
  }) {
    return changeSelectedDate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult? Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult? Function(_AddEvent value)? addNewEvent,
    TResult? Function(_DeleteEvent value)? deleteEvent,
    TResult? Function(_UpdateEvent value)? updateEvent,
  }) {
    return changeSelectedDate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult Function(_AddEvent value)? addNewEvent,
    TResult Function(_DeleteEvent value)? deleteEvent,
    TResult Function(_UpdateEvent value)? updateEvent,
    required TResult orElse(),
  }) {
    if (changeSelectedDate != null) {
      return changeSelectedDate(this);
    }
    return orElse();
  }
}

abstract class _ChangeSelectedDate implements CalendarEvent {
  const factory _ChangeSelectedDate(final DateTime newDate) =
      _$ChangeSelectedDateImpl;

  DateTime get newDate;
  @JsonKey(ignore: true)
  _$$ChangeSelectedDateImplCopyWith<_$ChangeSelectedDateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddEventImplCopyWith<$Res> {
  factory _$$AddEventImplCopyWith(
          _$AddEventImpl value, $Res Function(_$AddEventImpl) then) =
      __$$AddEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {EventModel model,
      ValueChanged<String> onFailure,
      VoidCallback onSuccess});
}

/// @nodoc
class __$$AddEventImplCopyWithImpl<$Res>
    extends _$CalendarEventCopyWithImpl<$Res, _$AddEventImpl>
    implements _$$AddEventImplCopyWith<$Res> {
  __$$AddEventImplCopyWithImpl(
      _$AddEventImpl _value, $Res Function(_$AddEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? onFailure = null,
    Object? onSuccess = null,
  }) {
    return _then(_$AddEventImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as EventModel,
      onFailure: null == onFailure
          ? _value.onFailure
          : onFailure // ignore: cast_nullable_to_non_nullable
              as ValueChanged<String>,
      onSuccess: null == onSuccess
          ? _value.onSuccess
          : onSuccess // ignore: cast_nullable_to_non_nullable
              as VoidCallback,
    ));
  }
}

/// @nodoc

class _$AddEventImpl implements _AddEvent {
  const _$AddEventImpl(
      {required this.model, required this.onFailure, required this.onSuccess});

  @override
  final EventModel model;
  @override
  final ValueChanged<String> onFailure;
  @override
  final VoidCallback onSuccess;

  @override
  String toString() {
    return 'CalendarEvent.addNewEvent(model: $model, onFailure: $onFailure, onSuccess: $onSuccess)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddEventImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.onFailure, onFailure) ||
                other.onFailure == onFailure) &&
            (identical(other.onSuccess, onSuccess) ||
                other.onSuccess == onSuccess));
  }

  @override
  int get hashCode => Object.hash(runtimeType, model, onFailure, onSuccess);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddEventImplCopyWith<_$AddEventImpl> get copyWith =>
      __$$AddEventImplCopyWithImpl<_$AddEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(DateTime newMonth) changeSelectedMonth,
    required TResult Function(DateTime newDate) changeSelectedDate,
    required TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)
        addNewEvent,
    required TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        deleteEvent,
    required TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        updateEvent,
  }) {
    return addNewEvent(model, onFailure, onSuccess);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(DateTime newMonth)? changeSelectedMonth,
    TResult? Function(DateTime newDate)? changeSelectedDate,
    TResult? Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult? Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult? Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
  }) {
    return addNewEvent?.call(model, onFailure, onSuccess);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(DateTime newMonth)? changeSelectedMonth,
    TResult Function(DateTime newDate)? changeSelectedDate,
    TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
    required TResult orElse(),
  }) {
    if (addNewEvent != null) {
      return addNewEvent(model, onFailure, onSuccess);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_ChangeSelectedMonth value) changeSelectedMonth,
    required TResult Function(_ChangeSelectedDate value) changeSelectedDate,
    required TResult Function(_AddEvent value) addNewEvent,
    required TResult Function(_DeleteEvent value) deleteEvent,
    required TResult Function(_UpdateEvent value) updateEvent,
  }) {
    return addNewEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult? Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult? Function(_AddEvent value)? addNewEvent,
    TResult? Function(_DeleteEvent value)? deleteEvent,
    TResult? Function(_UpdateEvent value)? updateEvent,
  }) {
    return addNewEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult Function(_AddEvent value)? addNewEvent,
    TResult Function(_DeleteEvent value)? deleteEvent,
    TResult Function(_UpdateEvent value)? updateEvent,
    required TResult orElse(),
  }) {
    if (addNewEvent != null) {
      return addNewEvent(this);
    }
    return orElse();
  }
}

abstract class _AddEvent implements CalendarEvent {
  const factory _AddEvent(
      {required final EventModel model,
      required final ValueChanged<String> onFailure,
      required final VoidCallback onSuccess}) = _$AddEventImpl;

  EventModel get model;
  ValueChanged<String> get onFailure;
  VoidCallback get onSuccess;
  @JsonKey(ignore: true)
  _$$AddEventImplCopyWith<_$AddEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DeleteEventImplCopyWith<$Res> {
  factory _$$DeleteEventImplCopyWith(
          _$DeleteEventImpl value, $Res Function(_$DeleteEventImpl) then) =
      __$$DeleteEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {EventModel model,
      VoidCallback onSuccess,
      ValueChanged<String> onFailure});
}

/// @nodoc
class __$$DeleteEventImplCopyWithImpl<$Res>
    extends _$CalendarEventCopyWithImpl<$Res, _$DeleteEventImpl>
    implements _$$DeleteEventImplCopyWith<$Res> {
  __$$DeleteEventImplCopyWithImpl(
      _$DeleteEventImpl _value, $Res Function(_$DeleteEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? model = null,
    Object? onSuccess = null,
    Object? onFailure = null,
  }) {
    return _then(_$DeleteEventImpl(
      model: null == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as EventModel,
      onSuccess: null == onSuccess
          ? _value.onSuccess
          : onSuccess // ignore: cast_nullable_to_non_nullable
              as VoidCallback,
      onFailure: null == onFailure
          ? _value.onFailure
          : onFailure // ignore: cast_nullable_to_non_nullable
              as ValueChanged<String>,
    ));
  }
}

/// @nodoc

class _$DeleteEventImpl implements _DeleteEvent {
  const _$DeleteEventImpl(
      {required this.model, required this.onSuccess, required this.onFailure});

  @override
  final EventModel model;
  @override
  final VoidCallback onSuccess;
  @override
  final ValueChanged<String> onFailure;

  @override
  String toString() {
    return 'CalendarEvent.deleteEvent(model: $model, onSuccess: $onSuccess, onFailure: $onFailure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteEventImpl &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.onSuccess, onSuccess) ||
                other.onSuccess == onSuccess) &&
            (identical(other.onFailure, onFailure) ||
                other.onFailure == onFailure));
  }

  @override
  int get hashCode => Object.hash(runtimeType, model, onSuccess, onFailure);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DeleteEventImplCopyWith<_$DeleteEventImpl> get copyWith =>
      __$$DeleteEventImplCopyWithImpl<_$DeleteEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(DateTime newMonth) changeSelectedMonth,
    required TResult Function(DateTime newDate) changeSelectedDate,
    required TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)
        addNewEvent,
    required TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        deleteEvent,
    required TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        updateEvent,
  }) {
    return deleteEvent(model, onSuccess, onFailure);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(DateTime newMonth)? changeSelectedMonth,
    TResult? Function(DateTime newDate)? changeSelectedDate,
    TResult? Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult? Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult? Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
  }) {
    return deleteEvent?.call(model, onSuccess, onFailure);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(DateTime newMonth)? changeSelectedMonth,
    TResult Function(DateTime newDate)? changeSelectedDate,
    TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
    required TResult orElse(),
  }) {
    if (deleteEvent != null) {
      return deleteEvent(model, onSuccess, onFailure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_ChangeSelectedMonth value) changeSelectedMonth,
    required TResult Function(_ChangeSelectedDate value) changeSelectedDate,
    required TResult Function(_AddEvent value) addNewEvent,
    required TResult Function(_DeleteEvent value) deleteEvent,
    required TResult Function(_UpdateEvent value) updateEvent,
  }) {
    return deleteEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult? Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult? Function(_AddEvent value)? addNewEvent,
    TResult? Function(_DeleteEvent value)? deleteEvent,
    TResult? Function(_UpdateEvent value)? updateEvent,
  }) {
    return deleteEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult Function(_AddEvent value)? addNewEvent,
    TResult Function(_DeleteEvent value)? deleteEvent,
    TResult Function(_UpdateEvent value)? updateEvent,
    required TResult orElse(),
  }) {
    if (deleteEvent != null) {
      return deleteEvent(this);
    }
    return orElse();
  }
}

abstract class _DeleteEvent implements CalendarEvent {
  const factory _DeleteEvent(
      {required final EventModel model,
      required final VoidCallback onSuccess,
      required final ValueChanged<String> onFailure}) = _$DeleteEventImpl;

  EventModel get model;
  VoidCallback get onSuccess;
  ValueChanged<String> get onFailure;
  @JsonKey(ignore: true)
  _$$DeleteEventImplCopyWith<_$DeleteEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateEventImplCopyWith<$Res> {
  factory _$$UpdateEventImplCopyWith(
          _$UpdateEventImpl value, $Res Function(_$UpdateEventImpl) then) =
      __$$UpdateEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {EventModel newModel,
      VoidCallback onSuccess,
      ValueChanged<String> onFailure});
}

/// @nodoc
class __$$UpdateEventImplCopyWithImpl<$Res>
    extends _$CalendarEventCopyWithImpl<$Res, _$UpdateEventImpl>
    implements _$$UpdateEventImplCopyWith<$Res> {
  __$$UpdateEventImplCopyWithImpl(
      _$UpdateEventImpl _value, $Res Function(_$UpdateEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? newModel = null,
    Object? onSuccess = null,
    Object? onFailure = null,
  }) {
    return _then(_$UpdateEventImpl(
      newModel: null == newModel
          ? _value.newModel
          : newModel // ignore: cast_nullable_to_non_nullable
              as EventModel,
      onSuccess: null == onSuccess
          ? _value.onSuccess
          : onSuccess // ignore: cast_nullable_to_non_nullable
              as VoidCallback,
      onFailure: null == onFailure
          ? _value.onFailure
          : onFailure // ignore: cast_nullable_to_non_nullable
              as ValueChanged<String>,
    ));
  }
}

/// @nodoc

class _$UpdateEventImpl implements _UpdateEvent {
  const _$UpdateEventImpl(
      {required this.newModel,
      required this.onSuccess,
      required this.onFailure});

  @override
  final EventModel newModel;
  @override
  final VoidCallback onSuccess;
  @override
  final ValueChanged<String> onFailure;

  @override
  String toString() {
    return 'CalendarEvent.updateEvent(newModel: $newModel, onSuccess: $onSuccess, onFailure: $onFailure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateEventImpl &&
            (identical(other.newModel, newModel) ||
                other.newModel == newModel) &&
            (identical(other.onSuccess, onSuccess) ||
                other.onSuccess == onSuccess) &&
            (identical(other.onFailure, onFailure) ||
                other.onFailure == onFailure));
  }

  @override
  int get hashCode => Object.hash(runtimeType, newModel, onSuccess, onFailure);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateEventImplCopyWith<_$UpdateEventImpl> get copyWith =>
      __$$UpdateEventImplCopyWithImpl<_$UpdateEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(DateTime newMonth) changeSelectedMonth,
    required TResult Function(DateTime newDate) changeSelectedDate,
    required TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)
        addNewEvent,
    required TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        deleteEvent,
    required TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)
        updateEvent,
  }) {
    return updateEvent(newModel, onSuccess, onFailure);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(DateTime newMonth)? changeSelectedMonth,
    TResult? Function(DateTime newDate)? changeSelectedDate,
    TResult? Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult? Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult? Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
  }) {
    return updateEvent?.call(newModel, onSuccess, onFailure);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(DateTime newMonth)? changeSelectedMonth,
    TResult Function(DateTime newDate)? changeSelectedDate,
    TResult Function(EventModel model, ValueChanged<String> onFailure,
            VoidCallback onSuccess)?
        addNewEvent,
    TResult Function(EventModel model, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        deleteEvent,
    TResult Function(EventModel newModel, VoidCallback onSuccess,
            ValueChanged<String> onFailure)?
        updateEvent,
    required TResult orElse(),
  }) {
    if (updateEvent != null) {
      return updateEvent(newModel, onSuccess, onFailure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_ChangeSelectedMonth value) changeSelectedMonth,
    required TResult Function(_ChangeSelectedDate value) changeSelectedDate,
    required TResult Function(_AddEvent value) addNewEvent,
    required TResult Function(_DeleteEvent value) deleteEvent,
    required TResult Function(_UpdateEvent value) updateEvent,
  }) {
    return updateEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult? Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult? Function(_AddEvent value)? addNewEvent,
    TResult? Function(_DeleteEvent value)? deleteEvent,
    TResult? Function(_UpdateEvent value)? updateEvent,
  }) {
    return updateEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_ChangeSelectedMonth value)? changeSelectedMonth,
    TResult Function(_ChangeSelectedDate value)? changeSelectedDate,
    TResult Function(_AddEvent value)? addNewEvent,
    TResult Function(_DeleteEvent value)? deleteEvent,
    TResult Function(_UpdateEvent value)? updateEvent,
    required TResult orElse(),
  }) {
    if (updateEvent != null) {
      return updateEvent(this);
    }
    return orElse();
  }
}

abstract class _UpdateEvent implements CalendarEvent {
  const factory _UpdateEvent(
      {required final EventModel newModel,
      required final VoidCallback onSuccess,
      required final ValueChanged<String> onFailure}) = _$UpdateEventImpl;

  EventModel get newModel;
  VoidCallback get onSuccess;
  ValueChanged<String> get onFailure;
  @JsonKey(ignore: true)
  _$$UpdateEventImplCopyWith<_$UpdateEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CalendarState {
  DateTime? get selectedMonth => throw _privateConstructorUsedError;
  DateTime? get selectedDate => throw _privateConstructorUsedError;
  List<EventModel> get models => throw _privateConstructorUsedError;
  FormStatus get status => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CalendarStateCopyWith<CalendarState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CalendarStateCopyWith<$Res> {
  factory $CalendarStateCopyWith(
          CalendarState value, $Res Function(CalendarState) then) =
      _$CalendarStateCopyWithImpl<$Res, CalendarState>;
  @useResult
  $Res call(
      {DateTime? selectedMonth,
      DateTime? selectedDate,
      List<EventModel> models,
      FormStatus status});
}

/// @nodoc
class _$CalendarStateCopyWithImpl<$Res, $Val extends CalendarState>
    implements $CalendarStateCopyWith<$Res> {
  _$CalendarStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? selectedMonth = freezed,
    Object? selectedDate = freezed,
    Object? models = null,
    Object? status = null,
  }) {
    return _then(_value.copyWith(
      selectedMonth: freezed == selectedMonth
          ? _value.selectedMonth
          : selectedMonth // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      selectedDate: freezed == selectedDate
          ? _value.selectedDate
          : selectedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      models: null == models
          ? _value.models
          : models // ignore: cast_nullable_to_non_nullable
              as List<EventModel>,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FormStatus,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CalendarStateImplCopyWith<$Res>
    implements $CalendarStateCopyWith<$Res> {
  factory _$$CalendarStateImplCopyWith(
          _$CalendarStateImpl value, $Res Function(_$CalendarStateImpl) then) =
      __$$CalendarStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {DateTime? selectedMonth,
      DateTime? selectedDate,
      List<EventModel> models,
      FormStatus status});
}

/// @nodoc
class __$$CalendarStateImplCopyWithImpl<$Res>
    extends _$CalendarStateCopyWithImpl<$Res, _$CalendarStateImpl>
    implements _$$CalendarStateImplCopyWith<$Res> {
  __$$CalendarStateImplCopyWithImpl(
      _$CalendarStateImpl _value, $Res Function(_$CalendarStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? selectedMonth = freezed,
    Object? selectedDate = freezed,
    Object? models = null,
    Object? status = null,
  }) {
    return _then(_$CalendarStateImpl(
      selectedMonth: freezed == selectedMonth
          ? _value.selectedMonth
          : selectedMonth // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      selectedDate: freezed == selectedDate
          ? _value.selectedDate
          : selectedDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      models: null == models
          ? _value._models
          : models // ignore: cast_nullable_to_non_nullable
              as List<EventModel>,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FormStatus,
    ));
  }
}

/// @nodoc

class _$CalendarStateImpl implements _CalendarState {
  _$CalendarStateImpl(
      {this.selectedMonth = null,
      this.selectedDate = null,
      final List<EventModel> models = const [],
      this.status = FormStatus.pure})
      : _models = models;

  @override
  @JsonKey()
  final DateTime? selectedMonth;
  @override
  @JsonKey()
  final DateTime? selectedDate;
  final List<EventModel> _models;
  @override
  @JsonKey()
  List<EventModel> get models {
    if (_models is EqualUnmodifiableListView) return _models;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_models);
  }

  @override
  @JsonKey()
  final FormStatus status;

  @override
  String toString() {
    return 'CalendarState(selectedMonth: $selectedMonth, selectedDate: $selectedDate, models: $models, status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalendarStateImpl &&
            (identical(other.selectedMonth, selectedMonth) ||
                other.selectedMonth == selectedMonth) &&
            (identical(other.selectedDate, selectedDate) ||
                other.selectedDate == selectedDate) &&
            const DeepCollectionEquality().equals(other._models, _models) &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(runtimeType, selectedMonth, selectedDate,
      const DeepCollectionEquality().hash(_models), status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CalendarStateImplCopyWith<_$CalendarStateImpl> get copyWith =>
      __$$CalendarStateImplCopyWithImpl<_$CalendarStateImpl>(this, _$identity);
}

abstract class _CalendarState implements CalendarState {
  factory _CalendarState(
      {final DateTime? selectedMonth,
      final DateTime? selectedDate,
      final List<EventModel> models,
      final FormStatus status}) = _$CalendarStateImpl;

  @override
  DateTime? get selectedMonth;
  @override
  DateTime? get selectedDate;
  @override
  List<EventModel> get models;
  @override
  FormStatus get status;
  @override
  @JsonKey(ignore: true)
  _$$CalendarStateImplCopyWith<_$CalendarStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
